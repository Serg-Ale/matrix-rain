#!/usr/bin/env python3
"""
Matrix Rain - Terminal Digital Rain Effect

A terminal-based Matrix digital rain animation featuring Japanese characters
(Katakana), numbers, and symbols - just like in the movie!

Features:
- Authentic Japanese characters (half-width and full-width Katakana)
- 8-shade green gradient for smooth, cinematic fading
- Glowing head effect (white head + bright green glow)
- Column-based rendering (no horizontal flickering)
- Multiple color themes and rainbow mode

Author: Created with Claude
License: MIT
"""

import argparse
import curses
import locale
import random
import sys
import time
from dataclasses import dataclass, field
from typing import List, Optional, Dict

# Set locale for Unicode support
locale.setlocale(locale.LC_ALL, '')

# Character sets - authentic Matrix style
# Half-width Katakana (most authentic to the movie)
HALF_WIDTH_KATAKANA = "ｦｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ"
# Full-width Katakana
FULL_WIDTH_KATAKANA = "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン"
# Numbers and symbols
NUMBERS = "0123456789"
SYMBOLS = ":<>*+=-@#$%&"
# Latin (less common, for variety)
LATIN = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

# Combined character set (weighted towards Japanese for authenticity)
MATRIX_CHARS = HALF_WIDTH_KATAKANA * 3 + FULL_WIDTH_KATAKANA * 2 + NUMBERS + SYMBOLS

# Color theme definitions (RGB values in curses scale: 0-1000)
COLOR_THEMES = {
    'green': [
        (1000, 1000, 1000),  # 0: White (head)
        (400, 1000, 400),    # 1: Very bright green (glow)
        (200, 900, 200),     # 2: Bright green (glow)
        (0, 800, 0),         # 3: Medium-bright green
        (0, 600, 0),         # 4: Medium green
        (0, 450, 0),         # 5: Dim green
        (0, 300, 0),         # 6: Dark green
        (0, 150, 0),         # 7: Very dark green (fade out)
    ],
    'red': [
        (1000, 1000, 1000),
        (1000, 400, 400),
        (900, 200, 200),
        (800, 0, 0),
        (600, 0, 0),
        (450, 0, 0),
        (300, 0, 0),
        (150, 0, 0),
    ],
    'blue': [
        (1000, 1000, 1000),
        (400, 400, 1000),
        (200, 200, 900),
        (0, 0, 800),
        (0, 0, 600),
        (0, 0, 450),
        (0, 0, 300),
        (0, 0, 150),
    ],
    'cyan': [
        (1000, 1000, 1000),
        (400, 1000, 1000),
        (200, 900, 900),
        (0, 800, 800),
        (0, 600, 600),
        (0, 450, 450),
        (0, 300, 300),
        (0, 150, 150),
    ],
    'magenta': [
        (1000, 1000, 1000),
        (1000, 400, 1000),
        (900, 200, 900),
        (800, 0, 800),
        (600, 0, 600),
        (450, 0, 450),
        (300, 0, 300),
        (150, 0, 150),
    ],
    'yellow': [
        (1000, 1000, 1000),
        (1000, 1000, 400),
        (900, 900, 200),
        (800, 800, 0),
        (600, 600, 0),
        (450, 450, 0),
        (300, 300, 0),
        (150, 150, 0),
    ],
    'white': [
        (1000, 1000, 1000),
        (900, 900, 900),
        (800, 800, 800),
        (650, 650, 650),
        (500, 500, 500),
        (350, 350, 350),
        (220, 220, 220),
        (120, 120, 120),
    ],
}

# Number of brightness levels
NUM_SHADES = 8

# Rainbow colors for rainbow mode
RAINBOW_SEQUENCE = ['red', 'yellow', 'green', 'cyan', 'blue', 'magenta']


@dataclass
class Column:
    """Represents a single column of falling rain."""
    x: int                          # Column position
    head_y: float = -1.0            # Current head position (float for smooth movement)
    speed: float = 0.5              # Fall speed (cells per frame)
    trail_length: int = 15          # Length of the visible trail
    spawn_delay: int = 0            # Frames to wait before starting
    active: bool = True             # Whether this column is active
    last_head_y: int = -1           # Last integer head position (for detecting movement)


class MatrixRain:
    """Main Matrix rain animation controller using column-based rendering."""
    
    def __init__(self, stdscr, color: str = 'green', speed: int = 5, 
                 density: int = 5, screensaver: bool = False, rainbow: bool = False):
        self.stdscr = stdscr
        self.color_name = color
        self.base_speed = speed / 10.0  # Normalize to 0.1 - 1.0
        self.density = density
        self.screensaver = screensaver
        self.rainbow = rainbow
        self.frame_count = 0
        
        # Get terminal dimensions
        self.height, self.width = stdscr.getmaxyx()
        
        # Character grid - stores the character at each position
        # Characters persist until overwritten by a new drop
        self.char_grid: List[List[str]] = [
            [' ' for _ in range(self.width)] for _ in range(self.height)
        ]
        
        # Brightness grid - stores brightness level (0=brightest, 7=dimmest, 8+=invisible)
        self.brightness_grid: List[List[int]] = [
            [NUM_SHADES + 1 for _ in range(self.width)] for _ in range(self.height)
        ]
        
        # Column states - one per terminal column
        self.columns: List[Column] = []
        
        # Setup curses
        self._setup_curses()
        self._setup_colors()
        
        # Initialize columns
        self._init_columns()
        
    def _setup_curses(self):
        """Configure curses settings."""
        curses.curs_set(0)          # Hide cursor
        self.stdscr.nodelay(True)   # Non-blocking input
        self.stdscr.timeout(0)      # Don't wait for input
        curses.start_color()
        curses.use_default_colors()
        
    def _setup_colors(self):
        """Initialize color pairs for the gradient effect using 256-color mode."""
        # Check if terminal supports color modification
        self.can_change_colors = curses.can_change_color()
        
        if self.can_change_colors:
            # Use custom colors for beautiful gradients
            theme = COLOR_THEMES.get(self.color_name, COLOR_THEMES['green'])
            
            # Define custom colors (starting from color 16 to avoid overwriting defaults)
            for i, (r, g, b) in enumerate(theme):
                try:
                    curses.init_color(16 + i, r, g, b)
                    curses.init_pair(i + 1, 16 + i, -1)
                except curses.error:
                    # Fallback if color init fails
                    self._setup_fallback_colors()
                    return
            
            # Setup rainbow colors if needed
            if self.rainbow:
                color_offset = 30  # Start rainbow colors at 30
                for theme_idx, theme_name in enumerate(RAINBOW_SEQUENCE):
                    theme = COLOR_THEMES[theme_name]
                    for shade_idx, (r, g, b) in enumerate(theme):
                        try:
                            color_num = color_offset + (theme_idx * NUM_SHADES) + shade_idx
                            curses.init_color(color_num, r, g, b)
                            curses.init_pair(color_num - 29 + NUM_SHADES, color_num, -1)
                        except curses.error:
                            pass
        else:
            self._setup_fallback_colors()
    
    def _setup_fallback_colors(self):
        """Fallback color setup for terminals that don't support color modification."""
        self.can_change_colors = False
        
        # Map color names to curses colors
        color_map = {
            'green': curses.COLOR_GREEN,
            'red': curses.COLOR_RED,
            'blue': curses.COLOR_BLUE,
            'cyan': curses.COLOR_CYAN,
            'magenta': curses.COLOR_MAGENTA,
            'yellow': curses.COLOR_YELLOW,
            'white': curses.COLOR_WHITE,
        }
        
        base_color = color_map.get(self.color_name, curses.COLOR_GREEN)
        
        # Create basic color pairs
        curses.init_pair(1, curses.COLOR_WHITE, -1)   # Head (white)
        curses.init_pair(2, base_color, -1)           # Bright
        curses.init_pair(3, base_color, -1)           # Medium
        curses.init_pair(4, base_color, -1)           # Dim
        
    def _init_columns(self):
        """Initialize all columns with staggered spawn delays."""
        self.columns = []
        for x in range(self.width - 1):  # -1 to avoid edge issues with wide chars
            col = Column(
                x=x,
                head_y=-random.randint(1, self.height),  # Start above screen
                speed=self._random_speed(),
                trail_length=self._random_trail_length(),
                spawn_delay=random.randint(0, 30),  # Stagger initial spawns
            )
            self.columns.append(col)
    
    def _random_speed(self) -> float:
        """Generate a random speed based on base speed setting."""
        # Speed varies between 0.3x and 1.5x of base speed
        return self.base_speed * random.uniform(0.3, 1.5)
    
    def _random_trail_length(self) -> int:
        """Generate a random trail length."""
        min_len = max(8, self.height // 6)
        max_len = max(min_len + 5, self.height // 2)
        return random.randint(min_len, max_len)
    
    def _random_char(self) -> str:
        """Get a random Matrix character."""
        return random.choice(MATRIX_CHARS)
    
    def _get_color_attr(self, brightness: int, column_x: int = 0) -> int:
        """Get the curses color attribute for a given brightness level."""
        if brightness >= NUM_SHADES:
            return 0  # Invisible
        
        if self.rainbow:
            # Cycle through rainbow colors based on column and frame
            theme_idx = (column_x + self.frame_count // 8) % len(RAINBOW_SEQUENCE)
            if self.can_change_colors:
                pair_num = NUM_SHADES + 1 + (theme_idx * NUM_SHADES) + brightness
                return curses.color_pair(pair_num)
            else:
                # Fallback rainbow
                colors = [curses.COLOR_RED, curses.COLOR_YELLOW, curses.COLOR_GREEN,
                         curses.COLOR_CYAN, curses.COLOR_BLUE, curses.COLOR_MAGENTA]
                curses.init_pair(100 + theme_idx, colors[theme_idx], -1)
                attr = curses.color_pair(100 + theme_idx)
                if brightness == 0:
                    return attr | curses.A_BOLD
                elif brightness > 4:
                    return attr | curses.A_DIM
                return attr
        
        if self.can_change_colors:
            # Use our custom gradient colors
            return curses.color_pair(brightness + 1)
        else:
            # Fallback: use attributes to simulate brightness
            if brightness == 0:
                return curses.color_pair(1) | curses.A_BOLD  # White head
            elif brightness <= 2:
                return curses.color_pair(2) | curses.A_BOLD  # Bright
            elif brightness <= 4:
                return curses.color_pair(3)                   # Medium
            else:
                return curses.color_pair(4) | curses.A_DIM    # Dim
    
    def _update_column(self, col: Column):
        """Update a single column's state."""
        # Handle spawn delay
        if col.spawn_delay > 0:
            col.spawn_delay -= 1
            return
        
        # Move the head down
        col.head_y += col.speed
        
        # Check if head has moved to a new cell
        current_head_y = int(col.head_y)
        
        if current_head_y != col.last_head_y and current_head_y >= 0:
            # Head moved to a new cell - place a new character
            if current_head_y < self.height:
                self.char_grid[current_head_y][col.x] = self._random_char()
                self.brightness_grid[current_head_y][col.x] = 0  # Brightest (head)
            
            col.last_head_y = current_head_y
        
        # Update brightness for the trail (create gradient effect)
        for y in range(self.height):
            if col.x >= self.width:
                continue
                
            distance_from_head = current_head_y - y
            
            if distance_from_head < 0:
                # Above the head - not part of trail yet
                continue
            elif distance_from_head == 0:
                # The head itself - brightest white
                self.brightness_grid[y][col.x] = 0
            elif distance_from_head <= 2:
                # Glow effect - very bright green (shades 1-2)
                self.brightness_grid[y][col.x] = distance_from_head
            elif distance_from_head < col.trail_length:
                # Main trail - gradient from bright to dim
                # Map distance to brightness levels 3-7
                progress = (distance_from_head - 2) / (col.trail_length - 2)
                brightness = 3 + int(progress * 4)  # 3 to 7
                self.brightness_grid[y][col.x] = min(brightness, NUM_SHADES - 1)
            else:
                # Beyond trail - fade out
                fade_distance = distance_from_head - col.trail_length
                self.brightness_grid[y][col.x] = min(NUM_SHADES + fade_distance, NUM_SHADES + 5)
        
        # Respawn column when it's fully off screen
        if col.head_y - col.trail_length > self.height + 10:
            self._respawn_column(col)
    
    def _respawn_column(self, col: Column):
        """Respawn a column at the top with new random properties."""
        # Only respawn based on density setting
        if random.random() > (self.density / 10.0):
            col.spawn_delay = random.randint(10, 50)  # Delay before respawning
        else:
            col.spawn_delay = random.randint(0, 10)
        
        col.head_y = -random.randint(1, 10)
        col.last_head_y = -1
        col.speed = self._random_speed()
        col.trail_length = self._random_trail_length()
    
    def _draw(self):
        """Draw the current state to the screen."""
        for y in range(self.height - 1):  # -1 to avoid bottom line issues
            for x in range(self.width - 1):  # -1 to avoid edge issues
                brightness = self.brightness_grid[y][x]
                
                if brightness > NUM_SHADES:
                    # Invisible - skip
                    continue
                
                char = self.char_grid[y][x]
                if char == ' ':
                    continue
                
                try:
                    attr = self._get_color_attr(brightness, x)
                    self.stdscr.addstr(y, x, char, attr)
                except curses.error:
                    # Ignore errors at screen boundaries
                    pass
    
    def _handle_resize(self):
        """Handle terminal resize."""
        new_height, new_width = self.stdscr.getmaxyx()
        
        if new_height != self.height or new_width != self.width:
            old_height, old_width = self.height, self.width
            self.height, self.width = new_height, new_width
            
            # Resize grids
            # Expand or shrink height
            if new_height > old_height:
                for _ in range(new_height - old_height):
                    self.char_grid.append([' ' for _ in range(new_width)])
                    self.brightness_grid.append([NUM_SHADES + 1 for _ in range(new_width)])
            elif new_height < old_height:
                self.char_grid = self.char_grid[:new_height]
                self.brightness_grid = self.brightness_grid[:new_height]
            
            # Expand or shrink width
            for y in range(len(self.char_grid)):
                if new_width > len(self.char_grid[y]):
                    self.char_grid[y].extend([' ' for _ in range(new_width - len(self.char_grid[y]))])
                    self.brightness_grid[y].extend([NUM_SHADES + 1 for _ in range(new_width - len(self.brightness_grid[y]))])
                elif new_width < len(self.char_grid[y]):
                    self.char_grid[y] = self.char_grid[y][:new_width]
                    self.brightness_grid[y] = self.brightness_grid[y][:new_width]
            
            # Add or remove columns
            if new_width > old_width:
                for x in range(old_width - 1, new_width - 1):
                    col = Column(
                        x=x,
                        head_y=-random.randint(1, self.height),
                        speed=self._random_speed(),
                        trail_length=self._random_trail_length(),
                        spawn_delay=random.randint(0, 20),
                    )
                    self.columns.append(col)
            elif new_width < old_width:
                self.columns = [c for c in self.columns if c.x < new_width - 1]
            
            self.stdscr.clear()
    
    def _check_input(self) -> bool:
        """Check for user input. Returns True if should exit."""
        try:
            key = self.stdscr.getch()
            if key != -1:  # A key was pressed
                if self.screensaver:
                    return True  # Exit on any key in screensaver mode
                elif key == ord('q') or key == ord('Q') or key == 27:  # q or Escape
                    return True
        except curses.error:
            pass
        return False
    
    def run(self):
        """Main animation loop."""
        # Calculate frame delay based on speed
        # Higher speed = shorter delay = faster animation
        base_delay = 0.03  # 30ms base (~33 FPS)
        
        try:
            while True:
                frame_start = time.time()
                
                # Check for input
                if self._check_input():
                    break
                
                # Handle terminal resize
                self._handle_resize()
                
                # Clear screen
                self.stdscr.erase()
                
                # Update all columns
                for col in self.columns:
                    self._update_column(col)
                
                # Draw everything
                self._draw()
                
                # Refresh screen
                self.stdscr.refresh()
                
                # Frame timing
                frame_time = time.time() - frame_start
                delay = max(0.01, base_delay - frame_time)
                time.sleep(delay)
                
                self.frame_count += 1
                
        except KeyboardInterrupt:
            pass


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Matrix Rain - Terminal Digital Rain Effect',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  matrix-rain                     # Classic green Matrix rain
  matrix-rain -c cyan             # Cyan colored rain
  matrix-rain -c red -s 8         # Fast red rain
  matrix-rain --rainbow           # Rainbow mode!
  matrix-rain -S                  # Screensaver mode (exit on keypress)
  matrix-rain -c green -s 7 -d 8  # Fast, dense green rain

Colors available: green, red, blue, cyan, magenta, yellow, white, rainbow

Press 'q' or Escape to exit (or any key in screensaver mode).
        '''
    )
    
    parser.add_argument(
        '-c', '--color',
        type=str,
        default='green',
        choices=list(COLOR_THEMES.keys()) + ['rainbow'],
        help='Rain color (default: green)'
    )
    
    parser.add_argument(
        '-s', '--speed',
        type=int,
        default=5,
        choices=range(1, 11),
        metavar='1-10',
        help='Animation speed, 1=slow, 10=fast (default: 5)'
    )
    
    parser.add_argument(
        '-d', '--density',
        type=int,
        default=5,
        choices=range(1, 11),
        metavar='1-10',
        help='Rain density, 1=sparse, 10=dense (default: 5)'
    )
    
    parser.add_argument(
        '-S', '--screensaver',
        action='store_true',
        help='Screensaver mode - exit on any keypress'
    )
    
    parser.add_argument(
        '-r', '--rainbow',
        action='store_true',
        help='Rainbow mode - cycling colors'
    )
    
    return parser.parse_args()


def main(stdscr):
    """Main entry point wrapped by curses."""
    args = parse_args()
    
    # Handle rainbow flag
    rainbow = args.rainbow or args.color == 'rainbow'
    color = 'green' if rainbow else args.color
    
    # Create and run the Matrix rain
    matrix = MatrixRain(
        stdscr,
        color=color,
        speed=args.speed,
        density=args.density,
        screensaver=args.screensaver,
        rainbow=rainbow
    )
    matrix.run()


if __name__ == '__main__':
    # Parse args first to handle --help without needing a TTY
    # We need to check for help before the TTY check
    if '-h' in sys.argv or '--help' in sys.argv:
        parse_args()
        sys.exit(0)
    
    # Check if we're running in a real terminal
    if not sys.stdout.isatty():
        print("Error: matrix-rain requires a terminal to run.", file=sys.stderr)
        print("Please run this command directly in your terminal.", file=sys.stderr)
        sys.exit(1)
    
    # Wrap main in curses wrapper for proper terminal handling
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        pass
    except curses.error as e:
        print(f"Terminal error: {e}", file=sys.stderr)
        print("Make sure you're running in a proper terminal.", file=sys.stderr)
        sys.exit(1)
    finally:
        # Ensure terminal is restored
        print("\033[?25h", end='')  # Show cursor
        print("\033[0m", end='')    # Reset colors

#!/usr/bin/env python3
"""
Matrix Rain - Terminal Digital Rain Effect

A terminal-based Matrix digital rain animation featuring Japanese characters
(Katakana), numbers, and symbols - just like in the movie!

Features:
- Authentic Japanese characters (half-width and full-width Katakana)
- 8-shade color gradient using 256-color palette
- Glowing head effect (white head + bright color glow)
- Column-based rendering (no horizontal flickering)
- Very dense, long-persistence trails for immersive effect
- Multiple color themes and rainbow mode

Author: Created with Claude
License: MIT
"""

import argparse
import curses
import locale
import random
import sys
import time
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Tuple

# Set locale for Unicode support
locale.setlocale(locale.LC_ALL, '')

# Character sets - authentic Matrix style
# Half-width Katakana (most authentic to the movie)
HALF_WIDTH_KATAKANA = "ｦｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ"
# Full-width Katakana
FULL_WIDTH_KATAKANA = "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン"
# Numbers and symbols
NUMBERS = "0123456789"
SYMBOLS = ":<>*+=-@#$%&"
# Latin (less common, for variety)
LATIN = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

# Combined character set (weighted towards Japanese for authenticity)
MATRIX_CHARS = HALF_WIDTH_KATAKANA * 3 + FULL_WIDTH_KATAKANA * 2 + NUMBERS + SYMBOLS

# Number of brightness levels
NUM_SHADES = 8

# =============================================================================
# 256-COLOR PALETTE MAPPING
# =============================================================================
# Using the standard 256-color xterm palette instead of curses.init_color()
# This ensures colors work correctly across all terminals (including Konsole)
#
# 256-color palette structure:
#   0-7:     Standard colors (black, red, green, yellow, blue, magenta, cyan, white)
#   8-15:    High-intensity colors
#   16-231:  6x6x6 color cube (216 colors)
#   232-255: Grayscale (24 shades, dark to light)
#
# Color cube formula: 16 + (36 × r) + (6 × g) + b, where r,g,b are 0-5
# =============================================================================

# Pre-defined color indices for each theme using 256-color palette
# Each theme has 8 shades: [head(white), glow1, glow2, bright, medium, dim, dark, very_dark]
COLOR_PALETTE = {
    'green': [
        15,   # 0: Bright white (head)
        48,   # 1: #00ff87 - very bright green/white glow
        41,   # 2: #00d75f - bright green glow
        40,   # 3: #00d700 - bright green
        34,   # 4: #00af00 - medium-bright green
        28,   # 5: #008700 - medium green
        22,   # 6: #005f00 - dark green
        236,  # 7: #303030 - very dark (almost black)
    ],
    'red': [
        15,   # 0: Bright white (head)
        210,  # 1: #ff8787 - very bright red/white glow
        203,  # 2: #ff5f5f - bright red glow
        196,  # 3: #ff0000 - bright red
        160,  # 4: #d70000 - medium-bright red
        124,  # 5: #af0000 - medium red
        88,   # 6: #870000 - dark red
        236,  # 7: #303030 - very dark
    ],
    'blue': [
        15,   # 0: Bright white (head)
        117,  # 1: #87d7ff - very bright blue/white glow
        75,   # 2: #5fafff - bright blue glow
        33,   # 3: #0087ff - bright blue
        27,   # 4: #005fff - medium-bright blue
        21,   # 5: #0000ff - medium blue
        19,   # 6: #0000af - dark blue
        236,  # 7: #303030 - very dark
    ],
    'cyan': [
        15,   # 0: Bright white (head)
        123,  # 1: #87ffff - very bright cyan/white glow
        87,   # 2: #5fffff - bright cyan glow
        51,   # 3: #00ffff - bright cyan
        44,   # 4: #00d7d7 - medium-bright cyan
        37,   # 5: #00afaf - medium cyan
        30,   # 6: #008787 - dark cyan
        236,  # 7: #303030 - very dark
    ],
    'magenta': [
        15,   # 0: Bright white (head)
        219,  # 1: #ffafff - very bright magenta/white glow
        213,  # 2: #ff87ff - bright magenta glow
        201,  # 3: #ff00ff - bright magenta
        165,  # 4: #d700ff - medium-bright magenta
        129,  # 5: #af00ff - medium magenta
        93,   # 6: #8700ff - dark magenta
        236,  # 7: #303030 - very dark
    ],
    'yellow': [
        15,   # 0: Bright white (head)
        228,  # 1: #ffff87 - very bright yellow/white glow
        227,  # 2: #ffff5f - bright yellow glow
        226,  # 3: #ffff00 - bright yellow
        220,  # 4: #ffd700 - medium-bright yellow
        178,  # 5: #d7af00 - medium yellow
        136,  # 6: #af8700 - dark yellow/gold
        236,  # 7: #303030 - very dark
    ],
    'white': [
        15,   # 0: Bright white (head)
        255,  # 1: #eeeeee - very bright white
        253,  # 2: #dadada - bright white
        251,  # 3: #c6c6c6 - light gray
        246,  # 4: #949494 - medium gray
        242,  # 5: #6c6c6c - dim gray
        238,  # 6: #444444 - dark gray
        235,  # 7: #262626 - very dark gray
    ],
}

# Rainbow colors sequence
RAINBOW_SEQUENCE = ['red', 'yellow', 'green', 'cyan', 'blue', 'magenta']


@dataclass
class Column:
    """Represents a single column of falling rain."""
    x: int                          # Column position
    head_y: float = -1.0            # Current head position (float for smooth movement)
    speed: float = 0.5              # Fall speed (cells per frame)
    trail_length: int = 20          # Length of the visible trail
    spawn_delay: int = 0            # Frames to wait before starting
    active: bool = True             # Whether this column is active
    last_head_y: int = -1           # Last integer head position (for detecting movement)


class MatrixRain:
    """Main Matrix rain animation controller using column-based rendering."""
    
    def __init__(self, stdscr, color: str = 'green', speed: int = 5, 
                 density: int = 7, screensaver: bool = False, rainbow: bool = False):
        self.stdscr = stdscr
        self.color_name = color
        self.base_speed = speed / 10.0  # Normalize to 0.1 - 1.0
        self.density = density
        self.screensaver = screensaver
        self.rainbow = rainbow
        self.frame_count = 0
        
        # Get terminal dimensions
        self.height, self.width = stdscr.getmaxyx()
        
        # Character grid - stores the character at each position
        # Characters persist until overwritten by a new drop
        self.char_grid: List[List[str]] = [
            [' ' for _ in range(self.width)] for _ in range(self.height)
        ]
        
        # Brightness grid - stores brightness level (0=brightest, 7=dimmest, 8+=invisible)
        self.brightness_grid: List[List[int]] = [
            [NUM_SHADES + 1 for _ in range(self.width)] for _ in range(self.height)
        ]
        
        # Column states - one per terminal column
        self.columns: List[Column] = []
        
        # Setup curses
        self._setup_curses()
        self._setup_colors()
        
        # Initialize columns
        self._init_columns()
        
    def _setup_curses(self):
        """Configure curses settings."""
        curses.curs_set(0)          # Hide cursor
        self.stdscr.nodelay(True)   # Non-blocking input
        self.stdscr.timeout(0)      # Don't wait for input
        curses.start_color()
        curses.use_default_colors()
        
    def _setup_colors(self):
        """Initialize color pairs using the 256-color palette."""
        # Get the color palette for the selected theme
        palette = COLOR_PALETTE.get(self.color_name, COLOR_PALETTE['green'])
        
        # Create color pairs for each brightness level
        # Using pairs 1-8 for the main theme
        for i, color_idx in enumerate(palette):
            try:
                curses.init_pair(i + 1, color_idx, -1)
            except curses.error:
                # Fallback to basic colors if 256-color fails
                self._setup_fallback_colors()
                return
        
        # Setup rainbow color pairs (pairs 10+)
        # Each rainbow color gets 8 shades
        pair_offset = 10
        for theme_idx, theme_name in enumerate(RAINBOW_SEQUENCE):
            theme_palette = COLOR_PALETTE[theme_name]
            for shade_idx, color_idx in enumerate(theme_palette):
                pair_num = pair_offset + (theme_idx * NUM_SHADES) + shade_idx
                try:
                    curses.init_pair(pair_num, color_idx, -1)
                except curses.error:
                    pass
    
    def _setup_fallback_colors(self):
        """Fallback color setup for terminals without 256-color support."""
        # Map color names to basic curses colors
        color_map = {
            'green': curses.COLOR_GREEN,
            'red': curses.COLOR_RED,
            'blue': curses.COLOR_BLUE,
            'cyan': curses.COLOR_CYAN,
            'magenta': curses.COLOR_MAGENTA,
            'yellow': curses.COLOR_YELLOW,
            'white': curses.COLOR_WHITE,
        }
        
        base_color = color_map.get(self.color_name, curses.COLOR_GREEN)
        
        # Create basic color pairs with attributes to simulate gradient
        curses.init_pair(1, curses.COLOR_WHITE, -1)   # Head (white)
        curses.init_pair(2, base_color, -1)           # Glow 1
        curses.init_pair(3, base_color, -1)           # Glow 2
        curses.init_pair(4, base_color, -1)           # Bright
        curses.init_pair(5, base_color, -1)           # Medium-bright
        curses.init_pair(6, base_color, -1)           # Medium
        curses.init_pair(7, base_color, -1)           # Dim
        curses.init_pair(8, base_color, -1)           # Very dim
        
    def _init_columns(self):
        """Initialize all columns with staggered spawn delays."""
        self.columns = []
        for x in range(self.width - 1):  # -1 to avoid edge issues with wide chars
            col = Column(
                x=x,
                head_y=-random.randint(1, self.height // 2),  # Start above screen
                speed=self._random_speed(),
                trail_length=self._random_trail_length(),
                spawn_delay=random.randint(0, 10),  # Short initial delays for quick start
            )
            self.columns.append(col)
    
    def _random_speed(self) -> float:
        """Generate a random speed based on base speed setting."""
        # Speed varies between 0.2x and 2.0x of base speed for more variety
        return self.base_speed * random.uniform(0.2, 2.0)
    
    def _random_trail_length(self) -> int:
        """Generate a random trail length - longer trails for more persistence."""
        # Trail length between 1/3 and 2/3 of screen height
        min_len = max(10, self.height // 3)
        max_len = max(min_len + 10, (self.height * 2) // 3)
        return random.randint(min_len, max_len)
    
    def _random_char(self) -> str:
        """Get a random Matrix character."""
        return random.choice(MATRIX_CHARS)
    
    def _get_color_attr(self, brightness: int, column_x: int = 0) -> int:
        """Get the curses color attribute for a given brightness level."""
        if brightness >= NUM_SHADES:
            return 0  # Invisible
        
        if self.rainbow:
            # Cycle through rainbow colors based on column and frame
            theme_idx = (column_x + self.frame_count // 10) % len(RAINBOW_SEQUENCE)
            pair_num = 10 + (theme_idx * NUM_SHADES) + brightness
            attr = curses.color_pair(pair_num)
            # Add bold for brightest shades
            if brightness <= 1:
                attr |= curses.A_BOLD
            return attr
        
        # Use the pre-defined color pairs (1-8)
        attr = curses.color_pair(brightness + 1)
        
        # Add bold for the brightest shades (head and glow)
        if brightness <= 2:
            attr |= curses.A_BOLD
        
        return attr
    
    def _update_column(self, col: Column):
        """Update a single column's state."""
        # Handle spawn delay
        if col.spawn_delay > 0:
            col.spawn_delay -= 1
            return
        
        # Move the head down
        col.head_y += col.speed
        
        # Check if head has moved to a new cell
        current_head_y = int(col.head_y)
        
        if current_head_y != col.last_head_y and current_head_y >= 0:
            # Head moved to a new cell - place a new character
            if current_head_y < self.height:
                self.char_grid[current_head_y][col.x] = self._random_char()
                self.brightness_grid[current_head_y][col.x] = 0  # Brightest (head)
            
            col.last_head_y = current_head_y
        
        # Update brightness for the trail (create gradient effect)
        for y in range(self.height):
            if col.x >= self.width:
                continue
                
            distance_from_head = current_head_y - y
            
            if distance_from_head < 0:
                # Above the head - not part of trail yet
                continue
            elif distance_from_head == 0:
                # The head itself - brightest white
                self.brightness_grid[y][col.x] = 0
            elif distance_from_head <= 3:
                # Glow effect - very bright (shades 1-2)
                # Extended glow zone for more dramatic effect
                self.brightness_grid[y][col.x] = min(distance_from_head, 2)
            elif distance_from_head < col.trail_length:
                # Main trail - gradient from bright to dim
                # Map distance to brightness levels 3-7
                progress = (distance_from_head - 3) / max(1, (col.trail_length - 3))
                brightness = 3 + int(progress * 4)  # 3 to 7
                self.brightness_grid[y][col.x] = min(brightness, NUM_SHADES - 1)
            else:
                # Beyond trail - start fading
                fade_distance = distance_from_head - col.trail_length
                # Slower fade for longer persistence
                fade_brightness = NUM_SHADES + (fade_distance // 2)
                self.brightness_grid[y][col.x] = min(fade_brightness, NUM_SHADES + 10)
        
        # Respawn column when it's fully off screen
        if col.head_y - col.trail_length > self.height + 5:
            self._respawn_column(col)
    
    def _respawn_column(self, col: Column):
        """Respawn a column at the top with new random properties."""
        # Higher density = shorter delay before respawning
        # At density 10, almost immediate respawn
        # At density 1, longer delays
        max_delay = max(1, 20 - (self.density * 2))
        
        # Random chance to respawn immediately for more organic feel
        if random.random() < (self.density / 10.0):
            col.spawn_delay = random.randint(0, max_delay // 2)
        else:
            col.spawn_delay = random.randint(0, max_delay)
        
        # Start position - some variation
        col.head_y = -random.randint(1, 8)
        col.last_head_y = -1
        col.speed = self._random_speed()
        col.trail_length = self._random_trail_length()
    
    def _draw(self):
        """Draw the current state to the screen."""
        for y in range(self.height):  # Draw to all rows including the last
            for x in range(self.width):  # Draw to all columns including the last
                brightness = self.brightness_grid[y][x]
                
                if brightness > NUM_SHADES:
                    # Invisible - skip drawing (leave as background)
                    continue
                
                char = self.char_grid[y][x]
                if char == ' ':
                    continue
                
                try:
                    attr = self._get_color_attr(brightness, x)
                    self.stdscr.addstr(y, x, char, attr)
                except curses.error:
                    # Ignore errors at screen boundaries
                    pass
    
    def _handle_resize(self):
        """Handle terminal resize."""
        new_height, new_width = self.stdscr.getmaxyx()
        
        if new_height != self.height or new_width != self.width:
            old_height, old_width = self.height, self.width
            self.height, self.width = new_height, new_width
            
            # Resize grids
            # Expand or shrink height
            if new_height > old_height:
                for _ in range(new_height - old_height):
                    self.char_grid.append([' ' for _ in range(new_width)])
                    self.brightness_grid.append([NUM_SHADES + 1 for _ in range(new_width)])
            elif new_height < old_height:
                self.char_grid = self.char_grid[:new_height]
                self.brightness_grid = self.brightness_grid[:new_height]
            
            # Expand or shrink width
            for y in range(len(self.char_grid)):
                if new_width > len(self.char_grid[y]):
                    self.char_grid[y].extend([' ' for _ in range(new_width - len(self.char_grid[y]))])
                    self.brightness_grid[y].extend([NUM_SHADES + 1 for _ in range(new_width - len(self.brightness_grid[y]))])
                elif new_width < len(self.char_grid[y]):
                    self.char_grid[y] = self.char_grid[y][:new_width]
                    self.brightness_grid[y] = self.brightness_grid[y][:new_width]
            
            # Add or remove columns
            if new_width > old_width:
                for x in range(old_width - 1, new_width - 1):
                    col = Column(
                        x=x,
                        head_y=-random.randint(1, self.height // 2),
                        speed=self._random_speed(),
                        trail_length=self._random_trail_length(),
                        spawn_delay=random.randint(0, 10),
                    )
                    self.columns.append(col)
            elif new_width < old_width:
                self.columns = [c for c in self.columns if c.x < new_width - 1]
            
            self.stdscr.clear()
    
    def _check_input(self) -> bool:
        """Check for user input. Returns True if should exit."""
        try:
            key = self.stdscr.getch()
            if key != -1:  # A key was pressed
                if self.screensaver:
                    return True  # Exit on any key in screensaver mode
                elif key == ord('q') or key == ord('Q') or key == 27:  # q or Escape
                    return True
        except curses.error:
            pass
        return False
    
    def run(self):
        """Main animation loop."""
        # Calculate frame delay based on speed
        # Higher speed = shorter delay = faster animation
        base_delay = 0.03  # 30ms base (~33 FPS)
        
        try:
            while True:
                frame_start = time.time()
                
                # Check for input
                if self._check_input():
                    break
                
                # Handle terminal resize
                self._handle_resize()
                
                # Clear screen
                self.stdscr.erase()
                
                # Update all columns
                for col in self.columns:
                    self._update_column(col)
                
                # Draw everything
                self._draw()
                
                # Refresh screen
                self.stdscr.refresh()
                
                # Frame timing
                frame_time = time.time() - frame_start
                delay = max(0.01, base_delay - frame_time)
                time.sleep(delay)
                
                self.frame_count += 1
                
        except KeyboardInterrupt:
            pass


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Matrix Rain - Terminal Digital Rain Effect',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  matrix-rain                     # Classic green Matrix rain
  matrix-rain -c cyan             # Cyan colored rain
  matrix-rain -c red -s 8         # Fast red rain
  matrix-rain --rainbow           # Rainbow mode!
  matrix-rain -S                  # Screensaver mode (exit on keypress)
  matrix-rain -c green -s 6 -d 9  # Fast, very dense green rain

Colors available: green, red, blue, cyan, magenta, yellow, white, rainbow

Press 'q' or Escape to exit (or any key in screensaver mode).
        '''
    )
    
    parser.add_argument(
        '-c', '--color',
        type=str,
        default='green',
        choices=list(COLOR_PALETTE.keys()) + ['rainbow'],
        help='Rain color (default: green)'
    )
    
    parser.add_argument(
        '-s', '--speed',
        type=int,
        default=5,
        choices=range(1, 11),
        metavar='1-10',
        help='Animation speed, 1=slow, 10=fast (default: 5)'
    )
    
    parser.add_argument(
        '-d', '--density',
        type=int,
        default=7,
        choices=range(1, 11),
        metavar='1-10',
        help='Rain density, 1=sparse, 10=very dense (default: 7)'
    )
    
    parser.add_argument(
        '-S', '--screensaver',
        action='store_true',
        help='Screensaver mode - exit on any keypress'
    )
    
    parser.add_argument(
        '-r', '--rainbow',
        action='store_true',
        help='Rainbow mode - cycling colors'
    )
    
    return parser.parse_args()


def main(stdscr):
    """Main entry point wrapped by curses."""
    args = parse_args()
    
    # Handle rainbow flag
    rainbow = args.rainbow or args.color == 'rainbow'
    color = 'green' if rainbow else args.color
    
    # Create and run the Matrix rain
    matrix = MatrixRain(
        stdscr,
        color=color,
        speed=args.speed,
        density=args.density,
        screensaver=args.screensaver,
        rainbow=rainbow
    )
    matrix.run()


if __name__ == '__main__':
    # Parse args first to handle --help without needing a TTY
    if '-h' in sys.argv or '--help' in sys.argv:
        parse_args()
        sys.exit(0)
    
    # Check if we're running in a real terminal
    if not sys.stdout.isatty():
        print("Error: matrix-rain requires a terminal to run.", file=sys.stderr)
        print("Please run this command directly in your terminal.", file=sys.stderr)
        sys.exit(1)
    
    # Wrap main in curses wrapper for proper terminal handling
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        pass
    except curses.error as e:
        print(f"Terminal error: {e}", file=sys.stderr)
        print("Make sure you're running in a proper terminal.", file=sys.stderr)
        sys.exit(1)
    finally:
        # Ensure terminal is restored
        print("\033[?25h", end='')  # Show cursor
        print("\033[0m", end='')    # Reset colors
